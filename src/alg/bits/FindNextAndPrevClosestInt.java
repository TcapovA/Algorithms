package alg.bits;

/**
 * Для заданного положительного числа выведите ближайшие наименьшее и наибольшее числа, которые имеют такое же количество
 * единичных битов в двоичном представлении
 */
public class FindNextAndPrevClosestInt {

    // Поиск следующего числа с тем бе количеством 1
    static int getNext(int n) {
        // p - позиция самого правого нуля, который не является завершающим
        int c = n;
        int c0 = 0; // кол-во нулей справа от p
        int c1 = 0; // кол-во единиц справа от p
        while (((c & 1) == 0) && (c != 0)) {
            ++c0;
            c >>= 1;
        }

        while ((c & 1) == 1) {
            c1++;
            c >>= 1;
        }

        /**
         * Ошибка, если  = 11..1100..00, то большего числа с таким же кол-вом единиц не существует
         */
        if (c0 + c1 == 31 || c0 + c1 == 0) {
            return -1;
        }

        int p = c0 + c1;

        n |= (1 << p);              // смена на 1 крайнего правого незавершающего нуля
        n &= ~((1 << p) - 1);       // сброс всех битов справа от р
        n |= (1 << (c1 - 1)) - 1;   // вставка (с1 - 1) единиц справа
        return n;
    }

    static int getPrev(int n) {
        int temp = n;
        int c0 = 0;
        int c1 = 0;
        while ((temp & 1) == 1) {
            c1++;
            temp >>= 1;
        }

        if (temp == 0) {
            return -1;
        }

        while (((temp & 1) == 0) && (temp != 0)) {
            c0++;
            temp >>= 1;
        }

        int p = c0 + c1;                // позиция крайней правой незавершающей 1
        n &= ((~0) << (p + 1));         // сброс битов, начиная с р

        int mask = (1 << (c1 + 1)) - 1; // последовательность из (с1 + 1) единиц
        n |= mask << (c0 - 1);

        return n;
    }
}
